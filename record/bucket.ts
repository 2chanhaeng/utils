/**
 * ```haskell
 * bucket :: (a -> String) -> (a -> Bool) -> [a] -> { key: [a] }
 * ```
 *
 * Buckets items from an iterable into a record based on a key generated by a function.
 *
 * @param {(item: T) => string} f - A function that takes an item and returns a string key.
 * @param {(item: T) => boolean} [validator] - An optional function to validate items before bucketing.
 * If not provided, all items are considered valid.
 * @returns {(items: Iterable<T>) => Record<string, T[]>} - A function that takes an iterable of items and returns a record
 * where keys are the results of applying `f` to each item, and values are arrays of items that correspond to each key.
 *
 * @example
 * ```ts
 * const items = [1, 2, 3, 4, 5, 6, 7];
 * const bucketed = bucket((x) => (x % 2 === 0 ? 'even' : 'odd'))(items);
 * console.log(bucketed);
 * // { even: [2, 4, 6], odd: [1, 3, 5, 7] }
 * const bucketedWithValidation = bucket(
 *   (x) => (x % 2 === 0 ? 'even' : 'odd'),
 *   (x) => x % 3 !== 0,
 * )(items);
 * console.log(bucketedWithValidation);
 * // { even: [2, 4], odd: [1, 5, 7] }
 * ```
 */
export default function bucket<T>(
  f: (item: T) => string,
  validator: (item: T) => boolean = () => true,
): (items: Iterable<T>) => Record<string, T[]> {
  return (items: Iterable<T>) => {
    const result: Record<string, T[]> = {};
    for (const item of items) {
      if (validator(item)) {
        const key = f(item);
        if (!result[key]) {
          result[key] = [];
        }
        result[key].push(item);
      }
    }
    return result;
  };
}
